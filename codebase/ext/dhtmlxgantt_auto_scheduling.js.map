{"version":3,"sources":["webpack:///dhtmlxgantt_auto_scheduling.js","webpack:///webpack/bootstrap 39c67343b4e330efcd62","webpack:///./sources/core/links_common.js","webpack:///./sources/ext/auto_scheduling.js","webpack:///./sources/utils/helpers.js"],"names":["Gantt","plugin","gantt","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_get_linked_task","link","getTarget","task","taskId","target","source","isTaskExists","getTask","role","assert","id","_get_link_target","_get_link_source","_formatLink","relations","this","isChildOf","isSummaryTask","from","_getImplicitLinks","respectTargetOffset","config","auto_scheduling_move_projects","targetDates","getSubtaskDates","start_date","end_date","to","$target","length","getState","drag_id","calculateDuration","fromTask","j","toTask","lag","subtaskLink","type","push","_convertToFinishToStartLink","_isAutoSchedulable","auto_scheduling","parent","selectOffset","eachTask","_getDirectDependencies","selectSuccessors","links","successors","linksIds","$source","getLink","concat","_getInheritedDependencies","stop","inheritedRelations","eachParent","apply","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","_getSuccessors","_getPredecessors","sourceTask","targetTask","res","finish_to_start","preferredStart","additionalLag","start_to_start","duration","finish_to_finish","start_to_finish","auto_scheduling_descendant_links","auto_scheduling_initial","auto_scheduling_strict","helpers","_autoSchedulingGraph","getVertices","ids","forEach","rel","vertices","sort","a","b","getGlobalTaskIndex","topologicalSort","edges","hash","$incoming","successor","S","filter","v","L","pop","node","tarjanStronglyConnectedComponents","strongConnect","vertexId","previousLink","getVertex","index","lowLink","connectedEdges","onStack","edge","w","undefined","Math","min","connectedComponent","tasks","connectedComponents","verticesHash","_autoSchedulingPath","getKey","join","getVirtualRoot","mixin","root_id","types","project","$virtual","filterDuplicates","keys","key","splice","getLinkedTasks","includePredecessors","startIds","visited","_getLinkedTasks","rootTask","visitedTasks","rootObj","chainRelations","children","getChildren","findLoops","cycles","graph","component","_autoSchedulingDateResolver","isFirstSmaller","small","big","valueOf","_hasDuration","isSmallerOrDefault","smallDate","bigDate","resolveRelationDate","getEndDate","minStart","linkId","defaultStart","relation","constraintDate","getConstraintDate","getClosestWorkTime","date","dir","predecessorEnd","successorStart","calculateEndDate","_autoSchedulingPlanner","generatePlan","getPredecessorEndDate","plan","plansHash","orderedIds","predecessorRelations","arrayMap","dateResolver","result","currentId","isLinkExists","predecessor","callEvent","applyProjectPlan","projectPlan","updateTasks","newDate","_autoSchedulingPreferredDates","startTask","Date","_autoSchedule","updateCallback","_autoscheduling_in_progress","path","updatedTasks","planner","autoSchedule","inclusive","_finalizeAutoSchedulingChanges","resetTime","batchUpdate","start","end","resetProjectDates","payload","updateTask","isCircularLink","_getConnectedGroup","manager","allRelations","findCycles","_attachAutoSchedulingHandlers","resetToStartLinksLags","skipped","originalLink","presentLinks","updatedLinks","_autoScheduleAfterLinkChange","attachEvent","predecessors","_preventCircularLink","_preventDescendantLink","_datesNotEqual","dateA","dateB","taskA","taskB","_notEqualTaskDates","task1","task2","milestone","movedTask","mode","_autoScheduleAfterDND","newTask","_lightBoxChangesHandler","oldTask","_autoschedule_lightbox_id","_lightBoxSaveHandler","getSecondsInUnit","unit","units","hour","arr","callback","workArray","slice","resArray","second","minute","day","week","month","quarter","year"],"mappings":"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","file":"dhtmlxgantt_auto_scheduling.js","sourcesContent":["/*!\n * @license\r\n * \r\n * dhtmlxGantt v.5.1.0 Professional\r\n * This software is covered by DHTMLX Enterprise License. Usage without proper license is prohibited.\r\n * \r\n * (c) Dinamenta, UAB.\r\n * \n */\nGantt.plugin(function(gantt){\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(gantt) {\r\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\r\n\r\n\tgantt._get_linked_task = function (link, getTarget) {\r\n\t\tvar task = null;\r\n\t\tvar taskId = getTarget ? link.target : link.source;\r\n\r\n\t\tif (gantt.isTaskExists(taskId)) {\r\n\t\t\ttask = gantt.getTask(taskId);\r\n\t\t}\r\n\t\tvar role = getTarget ? \"target\" : \"source\";\r\n\t\tgantt.assert(task, \"Link \" + role + \" not found. Task id=\" + taskId + \", link id=\" + link.id);\r\n\t\treturn task;\r\n\t};\r\n\tgantt._get_link_target = function (link) {\r\n\t\treturn gantt._get_linked_task(link, true);\r\n\t};\r\n\r\n\tgantt._get_link_source = function (link) {\r\n\t\treturn gantt._get_linked_task(link, false);\r\n\t};\r\n\r\n\r\n\tgantt._formatLink = function (link) {\r\n\t\tvar relations = [];\r\n\t\tvar target = this._get_link_target(link);\r\n\t\tvar source = this._get_link_source(link);\r\n\r\n\t\tif (!(source && target)) {\r\n\t\t\treturn relations;\r\n\t\t}\r\n\r\n\t\tif ((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))) {\r\n\t\t\treturn relations;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// there are three kinds of connections at this point\r\n\t\t// task -> task - regular link\r\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\r\n\t\t// project -> task - transform it into ([each subtask] -> task) links\r\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\r\n\r\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\r\n\t\t\treturn 0;\r\n\t\t});\r\n\r\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\r\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\r\n\t\t\tstart_date: target.start_date,\r\n\t\t\tend_date: target.end_date\r\n\t\t};\r\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\r\n\t\t\tif (!respectTargetOffset) {\r\n\t\t\t\treturn 0;\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\r\n\t\t\t\t\treturn gantt.calculateDuration({\r\n\t\t\t\t\t\tstart_date: targetDates.start_date,\r\n\t\t\t\t\t\tend_date: c.start_date,\r\n\t\t\t\t\t\ttask: source\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfor (var i = 0; i < from.length; i++) {\r\n\t\t\tvar fromTask = from[i];\r\n\t\t\tfor (var j = 0; j < to.length; j++) {\r\n\t\t\t\tvar toTask = to[j];\r\n\r\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\r\n\r\n\t\t\t\tvar subtaskLink = {\r\n\t\t\t\t\tid: link.id,\r\n\t\t\t\t\ttype: link.type,\r\n\t\t\t\t\tsource: fromTask.task,\r\n\t\t\t\t\ttarget: toTask.task,\r\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\r\n\t\t\t\t};\r\n\r\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn relations;\r\n\t};\r\n\r\ngantt._isAutoSchedulable = function(task){\r\n\treturn task.auto_scheduling !== false;\r\n};\r\n\r\ngantt._getImplicitLinks = function(link, parent, selectOffset){\r\n\tvar relations = [];\r\n\tif(this.isSummaryTask(parent)){\r\n\t\tthis.eachTask(function(c){\r\n\t\t\tif(!this.isSummaryTask(c))\r\n\t\t\t\trelations.push({task: c.id, lag: selectOffset(c)});\r\n\t\t}, parent.id);\r\n\t}else{\r\n\t\trelations.push({task:parent.id, lag: 0});\r\n\t}\r\n\r\n\t\treturn relations;\r\n\t};\r\n\r\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\r\n\r\n\t\tvar links = [],\r\n\t\t\tsuccessors = [];\r\n\r\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\r\n\r\n\tfor(var i = 0; i < linksIds.length; i++){\r\n\t\tvar link = this.getLink(linksIds[i]);\r\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\r\n\t\t\tvar target = this.getTask(link.target);\r\n\t\t\tif(this._isAutoSchedulable(target)){\r\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t\tfor (var i = 0; i < links.length; i++) {\r\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\r\n\t\t}\r\n\r\n\t\treturn successors;\r\n\t};\r\n\r\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\r\n\t\tvar successors = [];\r\n\tvar stop = false;\r\n\tvar inheritedRelations = [];\r\n\tif(this.isTaskExists(task.id)){\r\n\t\tthis.eachParent(function(parent){\r\n\t\t\tif(stop)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif(this.isSummaryTask(parent)){\r\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\r\n\t\t\t\t\tstop = true;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, this._getDirectDependencies(parent, selectSuccessors));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, task.id, this);\r\n\r\n\t\t\tfor (var i = 0; i < inheritedRelations.length; i++) {\r\n\r\n\t\t\t\tvar relProperty = selectSuccessors ? inheritedRelations[i].source : inheritedRelations[i].target;\r\n\r\n\t\t\t\tif (relProperty == task.id) {\r\n\t\t\t\t\tsuccessors.push(inheritedRelations[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn successors;\r\n\t};\r\n\r\n\r\n\tgantt._getDirectSuccessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getInheritedSuccessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getDirectPredecessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, false);\r\n\t};\r\n\r\n\tgantt._getInheritedPredecessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, false);\r\n\t};\r\n\r\n\r\n\tgantt._getSuccessors = function (task) {\r\n\t\treturn this._getDirectSuccessors(task).concat(this._getInheritedSuccessors(task));\r\n\t};\r\n\r\n\tgantt._getPredecessors = function (task) {\r\n\t\treturn this._getDirectPredecessors(task).concat(this._getInheritedPredecessors(task));\r\n\t};\r\n\r\n\r\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask) {\r\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\r\n\t\tvar res = {\r\n\t\t\ttarget: id,\r\n\t\t\tlink: gantt.config.links.finish_to_start,\r\n\t\t\tid: link.id,\r\n\t\t\tlag: link.lag || 0,\r\n\t\t\tsource: link.source,\r\n\t\t\tpreferredStart: null\r\n\t\t};\r\n\r\n\t\tvar additionalLag = 0;\r\n\t\tswitch (link.type) {\r\n\t\t\tcase gantt.config.links.start_to_start:\r\n\t\t\t\tadditionalLag = -sourceTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.finish_to_finish:\r\n\t\t\t\tadditionalLag = -targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.start_to_finish:\r\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tadditionalLag = 0;\r\n\t\t}\r\n\r\n\t\tres.lag += additionalLag;\r\n\t\treturn res;\r\n\t};\r\n};\n\n/***/ }),\n/* 1 */,\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(3);\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(0)(gantt);\r\n\r\ngantt.config.auto_scheduling = false;\r\ngantt.config.auto_scheduling_descendant_links = false;\r\ngantt.config.auto_scheduling_initial = true;\r\ngantt.config.auto_scheduling_strict = false;\r\ngantt.config.auto_scheduling_move_projects = true;\r\n\r\n(function(){\r\n\r\nvar helpers = __webpack_require__(4);\r\n\r\n\r\ngantt._autoSchedulingGraph = {\r\n\tgetVertices: function(relations){\r\n\t\tvar ids = {};\r\n\r\n\t\thelpers.forEach(relations, function(rel){\r\n\t\t\tids[rel.target] = rel.target;\r\n\t\t\tids[rel.source] = rel.source;\r\n\t\t});\r\n\r\n\t\tvar vertices = [];\r\n\t\tfor(var i in ids){\r\n\t\t\tvertices.push(ids[i]);\r\n\t\t}\r\n\r\n\t\treturn vertices.sort(function(a, b){ return gantt.getGlobalTaskIndex(a) - gantt.getGlobalTaskIndex(b);});\r\n\t},\r\n\ttopologicalSort: function(edges){\r\n\t\tvar vertices = this.getVertices(edges);\r\n\t\tvar hash = {};\r\n\r\n\t\tfor(var i = 0; i < vertices.length; i ++){\r\n\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\r\n\t\t}\r\n\r\n\t\tfor(var i = 0; i < edges.length; i++){\r\n\t\t\tvar successor = hash[edges[i].target];\r\n\t\t\tsuccessor.$target.push(i);\r\n\t\t\tsuccessor.$incoming = successor.$target.length;\r\n\t\t\thash[edges[i].source].$source.push(i);\r\n\r\n\t\t}\r\n\r\n\t\t// topological sort, Kahn's algorithm\r\n\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\r\n\r\n\t\tvar L = [];\r\n\r\n\t\twhile(S.length){\r\n\t\t\tvar n = S.pop();\r\n\r\n\t\t\tL.push(n);\r\n\r\n\t\t\tvar node = hash[n];\r\n\r\n\t\t\tfor(var i = 0; i < node.$source.length; i++){\r\n\t\t\t\tvar m = hash[edges[node.$source[i]].target];\r\n\t\t\t\tm.$incoming--;\r\n\t\t\t\tif(!m.$incoming){\r\n\t\t\t\t\tS.push(m.id);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn L;\r\n\r\n\t},\r\n\ttarjanStronglyConnectedComponents: function(vertices, edges){\r\n\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n\t\tvar verticesHash = {};\r\n\r\n\t\tvar index = 0;\r\n\t\tvar S = [];\r\n\t\tvar connectedEdges = [];\r\n\t\tvar connectedComponents = [];\r\n\r\n\t\thelpers.forEach(vertices, function(vertexId){\r\n\t\t\tvar vertex = getVertex(vertexId);\r\n\t\t\tif(vertex.index === undefined){\r\n\t\t\t\tstrongConnect(vertexId);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfunction strongConnect(vertexId, previousLink){\r\n\t\t\tvar v = getVertex(vertexId);\r\n\t\t\tv.index = index;\r\n\t\t\tv.lowLink = index;\r\n\t\t\tindex++;\r\n\r\n\t\t\tif(previousLink){\r\n\t\t\t\tconnectedEdges.push(previousLink);\r\n\t\t\t}\r\n\r\n\t\t\tS.push(v);\r\n\t\t\tv.onStack = true;\r\n\r\n\t\t\t// Consider successors of v\r\n\t\t\thelpers.forEach(edges, function(edge){\r\n\t\t\t\tif(edge.source != vertexId) return;\r\n\r\n\t\t\t\tvar v = getVertex(edge.source);\r\n\t\t\t\tvar w = getVertex(edge.target);\r\n\t\t\t\tif(w.index === undefined){\r\n\t\t\t\t\t// Successor w has not yet been visited; recurse on it\r\n\t\t\t\t\tstrongConnect(edge.target, edge);\r\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\r\n\t\t\t\t}else if(w.onStack){\r\n\t\t\t\t\t// Successor w is in stack S and hence in the current SCC\r\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\r\n\t\t\t\t\tconnectedEdges.push(edge);\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\t\t\t// If v is a root node, pop the stack and generate an SCC\r\n\t\t\tif(v.lowLink == v.index){\r\n\t\t\t\tvar connectedComponent = {tasks: [], links:[]};\r\n\t\t\t\tvar w;\r\n\t\t\t\tdo{\r\n\t\t\t\t\tvar rel = connectedEdges.pop();\r\n\t\t\t\t\tw = S.pop();\r\n\t\t\t\t\tw.onStack = false;\r\n\t\t\t\t\tconnectedComponent.tasks.push(w.id);\r\n\t\t\t\t\tif(rel){\r\n\t\t\t\t\t\tconnectedComponent.links.push(rel.id);\r\n\t\t\t\t\t}\r\n\t\t\t\t}while(w.id != v.id);\r\n\t\t\t\tconnectedComponents.push(connectedComponent);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn connectedComponents;\r\n\r\n\t\tfunction getVertex(id){\r\n\t\t\tif(!verticesHash[id]){\r\n\t\t\t\tverticesHash[id] = {id: id};\r\n\t\t\t}\r\n\r\n\t\t\treturn verticesHash[id];\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\ngantt._autoSchedulingPath = {\r\n\tgetKey: function(rel){\r\n\t\treturn [rel.lag, rel.link, rel.source, rel.target].join(\"_\");\r\n\t},\r\n\tgetVirtualRoot: function(){\r\n\t\treturn gantt.mixin(\r\n\t\t\tgantt.getSubtaskDates(),\r\n\t\t\t{\r\n\t\t\t\tid: gantt.config.root_id,\r\n\t\t\t\ttype: gantt.config.types.project,\r\n\t\t\t\t$source: [],\r\n\t\t\t\t$target: [],\r\n\t\t\t\t$virtual: true\r\n\t\t\t}\r\n\t\t);\r\n\t},\r\n\r\n\tfilterDuplicates: function(relations){\r\n\t\tvar keys = {};\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar key = this.getKey(relations[i]);\r\n\t\t\tif(keys[key]){\r\n\t\t\t\trelations.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t}else{\r\n\t\t\t\tkeys[key] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn relations;\r\n\t},\r\n\r\n\tgetLinkedTasks: function(id, includePredecessors){\r\n\t\tvar startIds = [id];\r\n\r\n\t\tvar relations = [];\r\n\t\tvar visited = {};\r\n\t\tfor(var i = 0; i < startIds.length; i++){\r\n\t\t\trelations = relations.concat(this._getLinkedTasks(startIds[i], visited, includePredecessors));\r\n\t\t}\r\n\r\n\t\trelations = this.filterDuplicates(relations);\r\n\t\treturn relations;\r\n\t},\r\n\r\n\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors){\r\n\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\r\n\t\tvar visited = visitedTasks || {};\r\n\r\n\t\tvar rootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\r\n\t\tvar relations = gantt._getSuccessors(rootObj);\r\n\r\n\t\tif(includePredecessors){\r\n\t\t\trelations.push.apply(relations, gantt._getPredecessors(rootObj));\r\n\t\t}\r\n\r\n\t\tvar chainRelations = [];\r\n\t\tfor(var i=0; i < relations.length; i++){\r\n\r\n\t\t\tif(visited[this.getKey(relations[i])])\r\n\t\t\t\tcontinue;\r\n\t\t\tvisited[this.getKey(relations[i])] = true;\r\n\t\t\tchainRelations = chainRelations.concat(this._getLinkedTasks(relations[i].target, visited, true));\r\n\t\t}\r\n\r\n\t\tvar children = gantt.getChildren(rootObj.id);\r\n\t\tfor(var i=0; i < children.length; i++){\r\n\t\t\trelations = relations.concat(this._getLinkedTasks(children[i], visited, true));\r\n\t\t}\r\n\r\n\t\tif(chainRelations.length){\r\n\t\t\trelations = relations.concat(chainRelations);\r\n\t\t}\r\n\r\n\t\treturn relations;\r\n\t},\r\n\r\n\tfindLoops: function(relations){\r\n\r\n\t\tvar cycles = [];\r\n\r\n\t\thelpers.forEach(relations, function(rel){\r\n\t\t\tif(rel.target == rel.source)\r\n\t\t\t\tcycles.push([rel.target, rel.source]);\r\n\t\t});\r\n\r\n\t\tvar graph =  gantt._autoSchedulingGraph;\r\n\t\tvar vertices = graph.getVertices(relations);\r\n\r\n\t\tvar connectedComponents = graph.tarjanStronglyConnectedComponents(vertices, relations);\r\n\r\n\t\thelpers.forEach(connectedComponents, function(component){\r\n\t\t\tif(component.tasks.length > 1){\r\n\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn cycles;\r\n\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingDateResolver = {\r\n\tisFirstSmaller: function(small, big, task){\r\n\t\tif(small.valueOf() < big.valueOf() && gantt._hasDuration(small, big, task))\r\n\t\t\treturn true;\r\n\t\treturn false;\r\n\t},\r\n\r\n\tisSmallerOrDefault: function(smallDate, bigDate, task){\r\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\r\n\t},\r\n\r\n\tresolveRelationDate: function(taskId, relations, getEndDate){\r\n\t\tvar minStart = null;\r\n\t\tvar linkId = null;\r\n\r\n\t\tvar defaultStart = null;\r\n\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar relation = relations[i];\r\n\t\t\ttaskId = relation.target;\r\n\r\n\t\t\tdefaultStart = relation.preferredStart;\r\n\r\n\t\t\tvar constraintDate = this.getConstraintDate(relation, getEndDate);\r\n\r\n\t\t\tif(this.isSmallerOrDefault(defaultStart, constraintDate, gantt.getTask(taskId)) && this.isSmallerOrDefault(minStart, constraintDate, gantt.getTask(taskId))){\r\n\t\t\t\tminStart = constraintDate;\r\n\t\t\t\tlinkId = relation.id;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif(minStart){\r\n\t\t\tminStart = gantt.getClosestWorkTime({date:minStart, dir:\"future\", task:gantt.getTask(taskId)});\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tlink: linkId,\r\n\t\t\ttask: taskId,\r\n\t\t\tstart_date: minStart\r\n\t\t};\r\n\t},\r\n\tgetConstraintDate: function(relation, getEndDate){\r\n\t\tvar predecessorEnd = getEndDate(relation.source);\r\n\t\tvar successor = gantt.getTask(relation.target);\r\n\r\n\t\tvar successorStart = gantt.getClosestWorkTime({date:predecessorEnd, dir:\"future\", task:successor});\r\n\r\n\t\tif(predecessorEnd && relation.lag && relation.lag*1 == relation.lag){\r\n\t\t\tsuccessorStart = gantt.calculateEndDate({start_date: predecessorEnd, duration: relation.lag*1, task: successor});\r\n\t\t}\r\n\r\n\t\treturn successorStart;\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingPlanner = {\r\n\tgeneratePlan: function(relations){\r\n\r\n\t\tvar graph = gantt._autoSchedulingGraph;\r\n\t\tvar orderedIds = graph.topologicalSort(relations);\r\n\t\tvar predecessorRelations = {},\r\n\t\t\tplansHash = {};\r\n\r\n\t\thelpers.arrayMap(orderedIds, function(v) {\r\n\t\t\tvar task = gantt.getTask(v);\r\n\t\t\tif(task.auto_scheduling === false){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tpredecessorRelations[v] = [];\r\n\t\t\tplansHash[v] = null;\r\n\t\t});\r\n\r\n\t\tfunction getPredecessorEndDate(id){\r\n\t\t\tvar plan = plansHash[id];\r\n\t\t\tvar task = gantt.getTask(id);\r\n\t\t\tvar res;\r\n\r\n\t\t\tif(!(plan && (plan.start_date || plan.end_date))){\r\n\t\t\t\tres = task.end_date;\r\n\t\t\t}else if(plan.end_date){\r\n\t\t\t\tres = plan.end_date;\r\n\t\t\t}else {\r\n\t\t\t\tres = gantt.calculateEndDate({start_date: plan.start_date, duration: task.duration, task: task});\r\n\t\t\t}\r\n\r\n\t\t\treturn res;\r\n\t\t}\r\n\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tif(predecessorRelations[relations[i].target]) {\r\n\t\t\t\tpredecessorRelations[relations[i].target].push(relations[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar dateResolver = gantt._autoSchedulingDateResolver;\r\n\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < orderedIds.length; i++){\r\n\t\t\tvar currentId = orderedIds[i];\r\n\r\n\t\t\tvar plan = dateResolver.resolveRelationDate(currentId, predecessorRelations[currentId] || [], getPredecessorEndDate);\r\n\r\n\r\n\t\t\tif(plan.start_date && gantt.isLinkExists(plan.link)){\r\n\t\t\t\tvar link = gantt.getLink(plan.link);\r\n\t\t\t\tvar task = gantt.getTask(currentId);\r\n\t\t\t\tvar predecessor = gantt.getTask(link.source);\r\n\r\n\t\t\t\tif (task.start_date.valueOf() !== plan.start_date.valueOf() && gantt.callEvent(\"onBeforeTaskAutoSchedule\", [task, plan.start_date, link, predecessor]) === false) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tplansHash[currentId] = plan;\r\n\t\t\tif(plan.start_date){\r\n\t\t\t\tresult.push(plan);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tapplyProjectPlan: function(projectPlan){\r\n\t\tvar plan, task, link, predecessor;\r\n\r\n\t\tvar updateTasks = [];\r\n\t\tfor(var i = 0; i <  projectPlan.length; i++){\r\n\t\t\tlink = null;\r\n\t\t\tpredecessor = null;\r\n\t\t\tplan = projectPlan[i];\r\n\r\n\t\t\tif(!plan.task) continue;\r\n\r\n\t\t\ttask = gantt.getTask(plan.task);\r\n\t\t\tif(plan.link){\r\n\t\t\t\tlink = gantt.getLink(plan.link);\r\n\t\t\t\tpredecessor = gantt.getTask(link.source);\r\n\t\t\t}\r\n\r\n\t\t\tvar newDate = null;\r\n\t\t\tif(plan.start_date && (task.start_date.valueOf() != plan.start_date.valueOf())){\r\n\t\t\t\tnewDate = plan.start_date;\r\n\t\t\t}\r\n\r\n\t\t\tif(!newDate) continue;\r\n\t\t\t\r\n\t\t\ttask.start_date = newDate;\r\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\r\n\r\n\t\t\tupdateTasks.push(task.id);\r\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [task, newDate, link, predecessor]);\r\n\r\n\t\t}\r\n\t\treturn updateTasks;\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingPreferredDates = function(startTask, relations){\r\n\tfor(var i = 0; i < relations.length; i++){\r\n\t\tvar rel = relations[i];\r\n\t\tvar task = gantt.getTask(rel.target);\r\n\r\n\t\tif(!gantt.config.auto_scheduling_strict || rel.target == startTask){\r\n\t\t\trel.preferredStart = new Date(task.start_date);\r\n\t\t}\r\n\t}\r\n};\r\n\r\ngantt._autoSchedule = function(id, relations, updateCallback){\r\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\r\n\t\treturn;\r\n\t}\r\n\tgantt._autoscheduling_in_progress = true;\r\n\r\n\tvar path = gantt._autoSchedulingPath;\r\n\r\n\tvar updatedTasks = [];\r\n\r\n\tvar cycles = path.findLoops(relations);\r\n\tif(cycles.length){\r\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\r\n\t}else{\r\n\r\n\t\tvar planner = gantt._autoSchedulingPlanner;\r\n\t\tgantt._autoSchedulingPreferredDates(id, relations);\r\n\r\n\t\tvar plan = planner.generatePlan(relations);\r\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\r\n\r\n\t\tif(updateCallback){\r\n\t\t\tupdateCallback(updatedTasks);\r\n\t\t}\r\n\t}\r\n\r\n\tgantt._autoscheduling_in_progress = false;\r\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\r\n\r\n\treturn updatedTasks;\r\n};\r\n\r\ngantt.autoSchedule = function(id, inclusive){\r\n\r\n\tif(inclusive === undefined){\r\n\t\tinclusive = true;\r\n\t}else{\r\n\t\tinclusive = !!inclusive;\r\n\t}\r\n\tvar relations =  gantt._autoSchedulingPath.getLinkedTasks(id, inclusive);\r\n\tgantt._autoSchedule(id, relations, gantt._finalizeAutoSchedulingChanges);\r\n};\r\n\r\ngantt._finalizeAutoSchedulingChanges = function(updatedTasks){\r\n\tfunction resetTime(task){\r\n\t\tif(batchUpdate)\r\n\t\t\treturn;\r\n\r\n\t\tvar start = task.start_date.valueOf(),\r\n\t\t\tend = task.end_date.valueOf();\r\n\r\n\t\tgantt.resetProjectDates(task);\r\n\t\tif(task.start_date.valueOf() != start || task.end_date.valueOf() != end){\r\n\t\t\tbatchUpdate = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar children = gantt.getChildren(task.id);\r\n\t\tfor(var i = 0; !batchUpdate && i < children.length; i++){\r\n\t\t\tresetTime(gantt.getTask(children[i]));\r\n\t\t}\r\n\t}\r\n\r\n\tvar batchUpdate = false;\r\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\r\n\tif(updatedTasks.length == 1){\r\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\r\n\t}else if(updatedTasks.length){\r\n\t\tbatchUpdate = true;\r\n\t}\r\n\r\n\tfunction payload(){\r\n\t\tfor(var i = 0; i < updatedTasks.length; i++){\r\n\t\t\tgantt.updateTask(updatedTasks[i]);\r\n\t\t}\r\n\t}\r\n\tif(batchUpdate){\r\n\t\tgantt.batchUpdate(payload);\r\n\t}else{\r\n\t\tpayload();\r\n\t}\r\n\r\n};\r\n\r\ngantt.isCircularLink = function(link){\r\n\treturn !!gantt._getConnectedGroup(link);\r\n\r\n};\r\n\r\ngantt._getConnectedGroup = function(link){\r\n\tvar manager = gantt._autoSchedulingPath;\r\n\r\n\tvar allRelations = manager.getLinkedTasks();\r\n\tif(!gantt.isLinkExists(link.id)){\r\n\t\tallRelations = allRelations.concat(gantt._formatLink(link));\r\n\t}\r\n\r\n\tvar cycles = manager.findLoops(allRelations);\r\n\r\n\tvar found = false;\r\n\tfor(var i = 0; (i < cycles.length) && !found; i++){\r\n\t\tvar links = cycles[i].links;\r\n\t\tfor(var j = 0; j < links.length; j++){\r\n\t\t\tif(links[j] == link.id){\r\n\t\t\t\treturn cycles[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn null;\r\n};\r\n\r\ngantt.findCycles = function(){\r\n\tvar manager = gantt._autoSchedulingPath;\r\n\r\n\tvar allRelations = manager.getLinkedTasks();\r\n\treturn manager.findLoops(allRelations);\r\n};\r\n\r\ngantt._attachAutoSchedulingHandlers = function(){\r\n\r\n\tgantt._autoScheduleAfterLinkChange = function (linkId, link) {\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tgantt.autoSchedule(link.source);\r\n\t\t}\r\n\t};\r\n\r\n\tgantt.attachEvent(\"onAfterLinkUpdate\", gantt._autoScheduleAfterLinkChange);\r\n\tgantt.attachEvent(\"onAfterLinkAdd\", gantt._autoScheduleAfterLinkChange);\r\n\r\n\tgantt.attachEvent(\"onAfterLinkDelete\", function(id, link){\r\n\t\tif (this.config.auto_scheduling && !this._autoscheduling_in_progress && this.isTaskExists(link.target)) {\r\n\t\t\t// after link deleted - auto schedule target for other relations that may be left\r\n\t\t\tvar target = this.getTask(link.target);\r\n\t\t\tvar predecessors = this._getPredecessors(target);\r\n\t\t\tif(predecessors.length){\r\n\t\t\t\tthis.autoSchedule(predecessors[0].source, false);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tgantt.attachEvent(\"onParse\", function(){\r\n\t\tif (gantt.config.auto_scheduling && gantt.config.auto_scheduling_initial) {\r\n\t\t\tgantt.autoSchedule();\r\n\t\t}\r\n\t});\r\n\r\n\tgantt._preventCircularLink = function(id, link){\r\n\t\tif(gantt.isCircularLink(link)){\r\n\t\t\tgantt.callEvent(\"onCircularLinkError\", [link, gantt._getConnectedGroup(link)]);\r\n\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\r\n\tgantt._preventDescendantLink = function(id, link){\r\n\t\tvar source = gantt.getTask(link.source),\r\n\t\t\ttarget = gantt.getTask(link.target);\r\n\r\n\t\tif(!gantt.config.auto_scheduling_descendant_links){\r\n\t\t\tif((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventCircularLink);\r\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventDescendantLink);\r\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventCircularLink);\r\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventDescendantLink);\r\n\r\n\tgantt._datesNotEqual = function(dateA, dateB, taskA, taskB){\r\n\t\tif(dateA.valueOf() > dateB.valueOf()){\r\n\t\t\treturn this._hasDuration({start_date: dateB, end_date: dateA, task: taskB});\r\n\t\t}else{\r\n\t\t\treturn this._hasDuration({start_date: dateA, end_date: dateB, task: taskA});\r\n\t\t}\r\n\t};\r\n\tgantt._notEqualTaskDates = function(task1, task2){\r\n\t\tif (this._datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\r\n\t\t\t((this._datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\r\n\t\t\t\ttask1.duration != task2.duration) && task1.type != gantt.config.types.milestone)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\r\n\tvar relations;\r\n\tvar movedTask;\r\n\tgantt.attachEvent(\"onBeforeTaskDrag\", function(id, mode, task){\r\n\t\tif(gantt.config.auto_scheduling_move_projects){\r\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\r\n\t\t\trelations = gantt._autoSchedulingPath.getLinkedTasks(id, true);\r\n\t\t\tmovedTask = id;\r\n\t\t}\r\n\t\treturn true;\r\n\t});\r\n\r\n\tfunction resetToStartLinksLags(taskId, relations){\r\n\t\tvar skipped = false;\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar originalLink = gantt.getLink(relations[i].id);\r\n\t\t\tif(originalLink.type == gantt.config.links.start_to_start || originalLink.type == gantt.config.links.start_to_finish){\r\n\t\t\t\trelations.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t\tskipped = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(skipped){\r\n\t\t\tvar presentLinks = {};\r\n\t\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\t\tpresentLinks[relations[i].id] = true;\r\n\t\t\t}\r\n\r\n\t\t\tvar updatedLinks = gantt._autoSchedulingPath.getLinkedTasks(taskId, true);\r\n\t\t\tfor(var i = 0; i < updatedLinks.length; i++){\r\n\t\t\t\tif(!presentLinks[updatedLinks[i].id]){\r\n\t\t\t\t\trelations.push(updatedLinks[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgantt._autoScheduleAfterDND = function(taskId, task){\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tvar newTask = this.getTask(taskId);\r\n\t\t\tif (gantt._notEqualTaskDates(task, newTask)){\r\n\t\t\t\tif(gantt.config.auto_scheduling_move_projects && movedTask == taskId){\r\n\r\n\t\t\t\t\tif(gantt.calculateDuration(task) != gantt.calculateDuration(newTask)){\r\n\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\r\n\t\t\t\t\t\t// recalculate these links if task duration has changed\r\n\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tgantt._autoSchedule(taskId, relations, gantt._finalizeAutoSchedulingChanges);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tgantt.autoSchedule(newTask.id);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\trelations = null;\r\n\t\tmovedTask = null;\r\n\t\treturn true;\r\n\t};\r\n\r\n\tgantt._lightBoxChangesHandler = function (taskId, task) {\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tvar oldTask = this.getTask(taskId);\r\n\t\t\tif (gantt._notEqualTaskDates(task, oldTask)) {\r\n\t\t\t\tgantt._autoschedule_lightbox_id = taskId;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\tgantt._lightBoxSaveHandler = function (taskId, task) {\r\n\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tif (gantt._autoschedule_lightbox_id && gantt._autoschedule_lightbox_id == taskId) {\r\n\t\t\t\tgantt._autoschedule_lightbox_id = null;\r\n\t\t\t\tgantt.autoSchedule(task.id);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n\r\n\r\n\tgantt.attachEvent(\"onBeforeTaskChanged\", function(id, mode, task){ return gantt._autoScheduleAfterDND(id, task); });\r\n\tgantt.attachEvent(\"onLightboxSave\", gantt._lightBoxChangesHandler);\r\n\tgantt.attachEvent(\"onAfterTaskUpdate\", gantt._lightBoxSaveHandler);\r\n\r\n\r\n};\r\n\r\n\r\ngantt.attachEvent(\"onGanttReady\", function(){\r\n\tgantt._attachAutoSchedulingHandlers();\r\n\t// attach handlers only when initialized for the first time\r\n\tgantt._attachAutoSchedulingHandlers = function(){};\r\n});\r\n\r\n})();\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nvar units = {\r\n\t\"second\": 1,\r\n\t\"minute\": 60,\r\n\t\"hour\": 60 * 60,\r\n\t\"day\": 60 * 60 * 24,\r\n\t\"week\": 60 * 60 * 24 * 7,\r\n\t\"month\": 60 * 60 * 24 * 30,\r\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\r\n\t\"year\": 60 * 60 * 24 * 365\r\n};\r\nfunction getSecondsInUnit(unit){\r\n\treturn units[unit] || units.hour;\r\n}\r\n\r\nfunction forEach(arr, callback){\r\n\tvar workArray = arr.slice();\r\n\tfor(var i = 0; i < workArray.length; i++){\r\n\t\tcallback(workArray[i], i);\r\n\t}\r\n}\r\n\r\nfunction arrayMap(arr, callback){\r\n\tvar workArray = arr.slice();\r\n\tvar resArray = [];\r\n\r\n\tfor(var i = 0; i < workArray.length; i++){\r\n\t\tresArray.push(callback(workArray[i], i));\r\n\t}\r\n\r\n\treturn resArray;\r\n}\r\n\r\nmodule.exports = {\r\n\tgetSecondsInUnit: getSecondsInUnit,\r\n\tforEach: forEach,\r\n\tarrayMap: arrayMap\r\n};\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// dhtmlxgantt_auto_scheduling.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 39c67343b4e330efcd62","module.exports = function(gantt) {\r\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\r\n\r\n\tgantt._get_linked_task = function (link, getTarget) {\r\n\t\tvar task = null;\r\n\t\tvar taskId = getTarget ? link.target : link.source;\r\n\r\n\t\tif (gantt.isTaskExists(taskId)) {\r\n\t\t\ttask = gantt.getTask(taskId);\r\n\t\t}\r\n\t\tvar role = getTarget ? \"target\" : \"source\";\r\n\t\tgantt.assert(task, \"Link \" + role + \" not found. Task id=\" + taskId + \", link id=\" + link.id);\r\n\t\treturn task;\r\n\t};\r\n\tgantt._get_link_target = function (link) {\r\n\t\treturn gantt._get_linked_task(link, true);\r\n\t};\r\n\r\n\tgantt._get_link_source = function (link) {\r\n\t\treturn gantt._get_linked_task(link, false);\r\n\t};\r\n\r\n\r\n\tgantt._formatLink = function (link) {\r\n\t\tvar relations = [];\r\n\t\tvar target = this._get_link_target(link);\r\n\t\tvar source = this._get_link_source(link);\r\n\r\n\t\tif (!(source && target)) {\r\n\t\t\treturn relations;\r\n\t\t}\r\n\r\n\t\tif ((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))) {\r\n\t\t\treturn relations;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// there are three kinds of connections at this point\r\n\t\t// task -> task - regular link\r\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\r\n\t\t// project -> task - transform it into ([each subtask] -> task) links\r\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\r\n\r\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\r\n\t\t\treturn 0;\r\n\t\t});\r\n\r\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\r\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\r\n\t\t\tstart_date: target.start_date,\r\n\t\t\tend_date: target.end_date\r\n\t\t};\r\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\r\n\t\t\tif (!respectTargetOffset) {\r\n\t\t\t\treturn 0;\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\r\n\t\t\t\t\treturn gantt.calculateDuration({\r\n\t\t\t\t\t\tstart_date: targetDates.start_date,\r\n\t\t\t\t\t\tend_date: c.start_date,\r\n\t\t\t\t\t\ttask: source\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfor (var i = 0; i < from.length; i++) {\r\n\t\t\tvar fromTask = from[i];\r\n\t\t\tfor (var j = 0; j < to.length; j++) {\r\n\t\t\t\tvar toTask = to[j];\r\n\r\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\r\n\r\n\t\t\t\tvar subtaskLink = {\r\n\t\t\t\t\tid: link.id,\r\n\t\t\t\t\ttype: link.type,\r\n\t\t\t\t\tsource: fromTask.task,\r\n\t\t\t\t\ttarget: toTask.task,\r\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\r\n\t\t\t\t};\r\n\r\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn relations;\r\n\t};\r\n\r\ngantt._isAutoSchedulable = function(task){\r\n\treturn task.auto_scheduling !== false;\r\n};\r\n\r\ngantt._getImplicitLinks = function(link, parent, selectOffset){\r\n\tvar relations = [];\r\n\tif(this.isSummaryTask(parent)){\r\n\t\tthis.eachTask(function(c){\r\n\t\t\tif(!this.isSummaryTask(c))\r\n\t\t\t\trelations.push({task: c.id, lag: selectOffset(c)});\r\n\t\t}, parent.id);\r\n\t}else{\r\n\t\trelations.push({task:parent.id, lag: 0});\r\n\t}\r\n\r\n\t\treturn relations;\r\n\t};\r\n\r\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\r\n\r\n\t\tvar links = [],\r\n\t\t\tsuccessors = [];\r\n\r\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\r\n\r\n\tfor(var i = 0; i < linksIds.length; i++){\r\n\t\tvar link = this.getLink(linksIds[i]);\r\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\r\n\t\t\tvar target = this.getTask(link.target);\r\n\t\t\tif(this._isAutoSchedulable(target)){\r\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t\tfor (var i = 0; i < links.length; i++) {\r\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\r\n\t\t}\r\n\r\n\t\treturn successors;\r\n\t};\r\n\r\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\r\n\t\tvar successors = [];\r\n\tvar stop = false;\r\n\tvar inheritedRelations = [];\r\n\tif(this.isTaskExists(task.id)){\r\n\t\tthis.eachParent(function(parent){\r\n\t\t\tif(stop)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tif(this.isSummaryTask(parent)){\r\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\r\n\t\t\t\t\tstop = true;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, this._getDirectDependencies(parent, selectSuccessors));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, task.id, this);\r\n\r\n\t\t\tfor (var i = 0; i < inheritedRelations.length; i++) {\r\n\r\n\t\t\t\tvar relProperty = selectSuccessors ? inheritedRelations[i].source : inheritedRelations[i].target;\r\n\r\n\t\t\t\tif (relProperty == task.id) {\r\n\t\t\t\t\tsuccessors.push(inheritedRelations[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn successors;\r\n\t};\r\n\r\n\r\n\tgantt._getDirectSuccessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getInheritedSuccessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, true);\r\n\t};\r\n\r\n\tgantt._getDirectPredecessors = function (task) {\r\n\t\treturn this._getDirectDependencies(task, false);\r\n\t};\r\n\r\n\tgantt._getInheritedPredecessors = function (task) {\r\n\t\treturn this._getInheritedDependencies(task, false);\r\n\t};\r\n\r\n\r\n\tgantt._getSuccessors = function (task) {\r\n\t\treturn this._getDirectSuccessors(task).concat(this._getInheritedSuccessors(task));\r\n\t};\r\n\r\n\tgantt._getPredecessors = function (task) {\r\n\t\treturn this._getDirectPredecessors(task).concat(this._getInheritedPredecessors(task));\r\n\t};\r\n\r\n\r\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask) {\r\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\r\n\t\tvar res = {\r\n\t\t\ttarget: id,\r\n\t\t\tlink: gantt.config.links.finish_to_start,\r\n\t\t\tid: link.id,\r\n\t\t\tlag: link.lag || 0,\r\n\t\t\tsource: link.source,\r\n\t\t\tpreferredStart: null\r\n\t\t};\r\n\r\n\t\tvar additionalLag = 0;\r\n\t\tswitch (link.type) {\r\n\t\t\tcase gantt.config.links.start_to_start:\r\n\t\t\t\tadditionalLag = -sourceTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.finish_to_finish:\r\n\t\t\t\tadditionalLag = -targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tcase gantt.config.links.start_to_finish:\r\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tadditionalLag = 0;\r\n\t\t}\r\n\r\n\t\tres.lag += additionalLag;\r\n\t\treturn res;\r\n\t};\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/core/links_common.js\n// module id = 0\n// module chunks = 1 3","require(\"../core/links_common\")(gantt);\r\n\r\ngantt.config.auto_scheduling = false;\r\ngantt.config.auto_scheduling_descendant_links = false;\r\ngantt.config.auto_scheduling_initial = true;\r\ngantt.config.auto_scheduling_strict = false;\r\ngantt.config.auto_scheduling_move_projects = true;\r\n\r\n(function(){\r\n\r\nvar helpers = require(\"../utils/helpers\");\r\n\r\n\r\ngantt._autoSchedulingGraph = {\r\n\tgetVertices: function(relations){\r\n\t\tvar ids = {};\r\n\r\n\t\thelpers.forEach(relations, function(rel){\r\n\t\t\tids[rel.target] = rel.target;\r\n\t\t\tids[rel.source] = rel.source;\r\n\t\t});\r\n\r\n\t\tvar vertices = [];\r\n\t\tfor(var i in ids){\r\n\t\t\tvertices.push(ids[i]);\r\n\t\t}\r\n\r\n\t\treturn vertices.sort(function(a, b){ return gantt.getGlobalTaskIndex(a) - gantt.getGlobalTaskIndex(b);});\r\n\t},\r\n\ttopologicalSort: function(edges){\r\n\t\tvar vertices = this.getVertices(edges);\r\n\t\tvar hash = {};\r\n\r\n\t\tfor(var i = 0; i < vertices.length; i ++){\r\n\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\r\n\t\t}\r\n\r\n\t\tfor(var i = 0; i < edges.length; i++){\r\n\t\t\tvar successor = hash[edges[i].target];\r\n\t\t\tsuccessor.$target.push(i);\r\n\t\t\tsuccessor.$incoming = successor.$target.length;\r\n\t\t\thash[edges[i].source].$source.push(i);\r\n\r\n\t\t}\r\n\r\n\t\t// topological sort, Kahn's algorithm\r\n\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\r\n\r\n\t\tvar L = [];\r\n\r\n\t\twhile(S.length){\r\n\t\t\tvar n = S.pop();\r\n\r\n\t\t\tL.push(n);\r\n\r\n\t\t\tvar node = hash[n];\r\n\r\n\t\t\tfor(var i = 0; i < node.$source.length; i++){\r\n\t\t\t\tvar m = hash[edges[node.$source[i]].target];\r\n\t\t\t\tm.$incoming--;\r\n\t\t\t\tif(!m.$incoming){\r\n\t\t\t\t\tS.push(m.id);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn L;\r\n\r\n\t},\r\n\ttarjanStronglyConnectedComponents: function(vertices, edges){\r\n\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n\t\tvar verticesHash = {};\r\n\r\n\t\tvar index = 0;\r\n\t\tvar S = [];\r\n\t\tvar connectedEdges = [];\r\n\t\tvar connectedComponents = [];\r\n\r\n\t\thelpers.forEach(vertices, function(vertexId){\r\n\t\t\tvar vertex = getVertex(vertexId);\r\n\t\t\tif(vertex.index === undefined){\r\n\t\t\t\tstrongConnect(vertexId);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tfunction strongConnect(vertexId, previousLink){\r\n\t\t\tvar v = getVertex(vertexId);\r\n\t\t\tv.index = index;\r\n\t\t\tv.lowLink = index;\r\n\t\t\tindex++;\r\n\r\n\t\t\tif(previousLink){\r\n\t\t\t\tconnectedEdges.push(previousLink);\r\n\t\t\t}\r\n\r\n\t\t\tS.push(v);\r\n\t\t\tv.onStack = true;\r\n\r\n\t\t\t// Consider successors of v\r\n\t\t\thelpers.forEach(edges, function(edge){\r\n\t\t\t\tif(edge.source != vertexId) return;\r\n\r\n\t\t\t\tvar v = getVertex(edge.source);\r\n\t\t\t\tvar w = getVertex(edge.target);\r\n\t\t\t\tif(w.index === undefined){\r\n\t\t\t\t\t// Successor w has not yet been visited; recurse on it\r\n\t\t\t\t\tstrongConnect(edge.target, edge);\r\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\r\n\t\t\t\t}else if(w.onStack){\r\n\t\t\t\t\t// Successor w is in stack S and hence in the current SCC\r\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\r\n\t\t\t\t\tconnectedEdges.push(edge);\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\t\t\t// If v is a root node, pop the stack and generate an SCC\r\n\t\t\tif(v.lowLink == v.index){\r\n\t\t\t\tvar connectedComponent = {tasks: [], links:[]};\r\n\t\t\t\tvar w;\r\n\t\t\t\tdo{\r\n\t\t\t\t\tvar rel = connectedEdges.pop();\r\n\t\t\t\t\tw = S.pop();\r\n\t\t\t\t\tw.onStack = false;\r\n\t\t\t\t\tconnectedComponent.tasks.push(w.id);\r\n\t\t\t\t\tif(rel){\r\n\t\t\t\t\t\tconnectedComponent.links.push(rel.id);\r\n\t\t\t\t\t}\r\n\t\t\t\t}while(w.id != v.id);\r\n\t\t\t\tconnectedComponents.push(connectedComponent);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn connectedComponents;\r\n\r\n\t\tfunction getVertex(id){\r\n\t\t\tif(!verticesHash[id]){\r\n\t\t\t\tverticesHash[id] = {id: id};\r\n\t\t\t}\r\n\r\n\t\t\treturn verticesHash[id];\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\ngantt._autoSchedulingPath = {\r\n\tgetKey: function(rel){\r\n\t\treturn [rel.lag, rel.link, rel.source, rel.target].join(\"_\");\r\n\t},\r\n\tgetVirtualRoot: function(){\r\n\t\treturn gantt.mixin(\r\n\t\t\tgantt.getSubtaskDates(),\r\n\t\t\t{\r\n\t\t\t\tid: gantt.config.root_id,\r\n\t\t\t\ttype: gantt.config.types.project,\r\n\t\t\t\t$source: [],\r\n\t\t\t\t$target: [],\r\n\t\t\t\t$virtual: true\r\n\t\t\t}\r\n\t\t);\r\n\t},\r\n\r\n\tfilterDuplicates: function(relations){\r\n\t\tvar keys = {};\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar key = this.getKey(relations[i]);\r\n\t\t\tif(keys[key]){\r\n\t\t\t\trelations.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t}else{\r\n\t\t\t\tkeys[key] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn relations;\r\n\t},\r\n\r\n\tgetLinkedTasks: function(id, includePredecessors){\r\n\t\tvar startIds = [id];\r\n\r\n\t\tvar relations = [];\r\n\t\tvar visited = {};\r\n\t\tfor(var i = 0; i < startIds.length; i++){\r\n\t\t\trelations = relations.concat(this._getLinkedTasks(startIds[i], visited, includePredecessors));\r\n\t\t}\r\n\r\n\t\trelations = this.filterDuplicates(relations);\r\n\t\treturn relations;\r\n\t},\r\n\r\n\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors){\r\n\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\r\n\t\tvar visited = visitedTasks || {};\r\n\r\n\t\tvar rootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\r\n\t\tvar relations = gantt._getSuccessors(rootObj);\r\n\r\n\t\tif(includePredecessors){\r\n\t\t\trelations.push.apply(relations, gantt._getPredecessors(rootObj));\r\n\t\t}\r\n\r\n\t\tvar chainRelations = [];\r\n\t\tfor(var i=0; i < relations.length; i++){\r\n\r\n\t\t\tif(visited[this.getKey(relations[i])])\r\n\t\t\t\tcontinue;\r\n\t\t\tvisited[this.getKey(relations[i])] = true;\r\n\t\t\tchainRelations = chainRelations.concat(this._getLinkedTasks(relations[i].target, visited, true));\r\n\t\t}\r\n\r\n\t\tvar children = gantt.getChildren(rootObj.id);\r\n\t\tfor(var i=0; i < children.length; i++){\r\n\t\t\trelations = relations.concat(this._getLinkedTasks(children[i], visited, true));\r\n\t\t}\r\n\r\n\t\tif(chainRelations.length){\r\n\t\t\trelations = relations.concat(chainRelations);\r\n\t\t}\r\n\r\n\t\treturn relations;\r\n\t},\r\n\r\n\tfindLoops: function(relations){\r\n\r\n\t\tvar cycles = [];\r\n\r\n\t\thelpers.forEach(relations, function(rel){\r\n\t\t\tif(rel.target == rel.source)\r\n\t\t\t\tcycles.push([rel.target, rel.source]);\r\n\t\t});\r\n\r\n\t\tvar graph =  gantt._autoSchedulingGraph;\r\n\t\tvar vertices = graph.getVertices(relations);\r\n\r\n\t\tvar connectedComponents = graph.tarjanStronglyConnectedComponents(vertices, relations);\r\n\r\n\t\thelpers.forEach(connectedComponents, function(component){\r\n\t\t\tif(component.tasks.length > 1){\r\n\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn cycles;\r\n\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingDateResolver = {\r\n\tisFirstSmaller: function(small, big, task){\r\n\t\tif(small.valueOf() < big.valueOf() && gantt._hasDuration(small, big, task))\r\n\t\t\treturn true;\r\n\t\treturn false;\r\n\t},\r\n\r\n\tisSmallerOrDefault: function(smallDate, bigDate, task){\r\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\r\n\t},\r\n\r\n\tresolveRelationDate: function(taskId, relations, getEndDate){\r\n\t\tvar minStart = null;\r\n\t\tvar linkId = null;\r\n\r\n\t\tvar defaultStart = null;\r\n\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar relation = relations[i];\r\n\t\t\ttaskId = relation.target;\r\n\r\n\t\t\tdefaultStart = relation.preferredStart;\r\n\r\n\t\t\tvar constraintDate = this.getConstraintDate(relation, getEndDate);\r\n\r\n\t\t\tif(this.isSmallerOrDefault(defaultStart, constraintDate, gantt.getTask(taskId)) && this.isSmallerOrDefault(minStart, constraintDate, gantt.getTask(taskId))){\r\n\t\t\t\tminStart = constraintDate;\r\n\t\t\t\tlinkId = relation.id;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif(minStart){\r\n\t\t\tminStart = gantt.getClosestWorkTime({date:minStart, dir:\"future\", task:gantt.getTask(taskId)});\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tlink: linkId,\r\n\t\t\ttask: taskId,\r\n\t\t\tstart_date: minStart\r\n\t\t};\r\n\t},\r\n\tgetConstraintDate: function(relation, getEndDate){\r\n\t\tvar predecessorEnd = getEndDate(relation.source);\r\n\t\tvar successor = gantt.getTask(relation.target);\r\n\r\n\t\tvar successorStart = gantt.getClosestWorkTime({date:predecessorEnd, dir:\"future\", task:successor});\r\n\r\n\t\tif(predecessorEnd && relation.lag && relation.lag*1 == relation.lag){\r\n\t\t\tsuccessorStart = gantt.calculateEndDate({start_date: predecessorEnd, duration: relation.lag*1, task: successor});\r\n\t\t}\r\n\r\n\t\treturn successorStart;\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingPlanner = {\r\n\tgeneratePlan: function(relations){\r\n\r\n\t\tvar graph = gantt._autoSchedulingGraph;\r\n\t\tvar orderedIds = graph.topologicalSort(relations);\r\n\t\tvar predecessorRelations = {},\r\n\t\t\tplansHash = {};\r\n\r\n\t\thelpers.arrayMap(orderedIds, function(v) {\r\n\t\t\tvar task = gantt.getTask(v);\r\n\t\t\tif(task.auto_scheduling === false){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tpredecessorRelations[v] = [];\r\n\t\t\tplansHash[v] = null;\r\n\t\t});\r\n\r\n\t\tfunction getPredecessorEndDate(id){\r\n\t\t\tvar plan = plansHash[id];\r\n\t\t\tvar task = gantt.getTask(id);\r\n\t\t\tvar res;\r\n\r\n\t\t\tif(!(plan && (plan.start_date || plan.end_date))){\r\n\t\t\t\tres = task.end_date;\r\n\t\t\t}else if(plan.end_date){\r\n\t\t\t\tres = plan.end_date;\r\n\t\t\t}else {\r\n\t\t\t\tres = gantt.calculateEndDate({start_date: plan.start_date, duration: task.duration, task: task});\r\n\t\t\t}\r\n\r\n\t\t\treturn res;\r\n\t\t}\r\n\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tif(predecessorRelations[relations[i].target]) {\r\n\t\t\t\tpredecessorRelations[relations[i].target].push(relations[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar dateResolver = gantt._autoSchedulingDateResolver;\r\n\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < orderedIds.length; i++){\r\n\t\t\tvar currentId = orderedIds[i];\r\n\r\n\t\t\tvar plan = dateResolver.resolveRelationDate(currentId, predecessorRelations[currentId] || [], getPredecessorEndDate);\r\n\r\n\r\n\t\t\tif(plan.start_date && gantt.isLinkExists(plan.link)){\r\n\t\t\t\tvar link = gantt.getLink(plan.link);\r\n\t\t\t\tvar task = gantt.getTask(currentId);\r\n\t\t\t\tvar predecessor = gantt.getTask(link.source);\r\n\r\n\t\t\t\tif (task.start_date.valueOf() !== plan.start_date.valueOf() && gantt.callEvent(\"onBeforeTaskAutoSchedule\", [task, plan.start_date, link, predecessor]) === false) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tplansHash[currentId] = plan;\r\n\t\t\tif(plan.start_date){\r\n\t\t\t\tresult.push(plan);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tapplyProjectPlan: function(projectPlan){\r\n\t\tvar plan, task, link, predecessor;\r\n\r\n\t\tvar updateTasks = [];\r\n\t\tfor(var i = 0; i <  projectPlan.length; i++){\r\n\t\t\tlink = null;\r\n\t\t\tpredecessor = null;\r\n\t\t\tplan = projectPlan[i];\r\n\r\n\t\t\tif(!plan.task) continue;\r\n\r\n\t\t\ttask = gantt.getTask(plan.task);\r\n\t\t\tif(plan.link){\r\n\t\t\t\tlink = gantt.getLink(plan.link);\r\n\t\t\t\tpredecessor = gantt.getTask(link.source);\r\n\t\t\t}\r\n\r\n\t\t\tvar newDate = null;\r\n\t\t\tif(plan.start_date && (task.start_date.valueOf() != plan.start_date.valueOf())){\r\n\t\t\t\tnewDate = plan.start_date;\r\n\t\t\t}\r\n\r\n\t\t\tif(!newDate) continue;\r\n\t\t\t\r\n\t\t\ttask.start_date = newDate;\r\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\r\n\r\n\t\t\tupdateTasks.push(task.id);\r\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [task, newDate, link, predecessor]);\r\n\r\n\t\t}\r\n\t\treturn updateTasks;\r\n\t}\r\n};\r\n\r\ngantt._autoSchedulingPreferredDates = function(startTask, relations){\r\n\tfor(var i = 0; i < relations.length; i++){\r\n\t\tvar rel = relations[i];\r\n\t\tvar task = gantt.getTask(rel.target);\r\n\r\n\t\tif(!gantt.config.auto_scheduling_strict || rel.target == startTask){\r\n\t\t\trel.preferredStart = new Date(task.start_date);\r\n\t\t}\r\n\t}\r\n};\r\n\r\ngantt._autoSchedule = function(id, relations, updateCallback){\r\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\r\n\t\treturn;\r\n\t}\r\n\tgantt._autoscheduling_in_progress = true;\r\n\r\n\tvar path = gantt._autoSchedulingPath;\r\n\r\n\tvar updatedTasks = [];\r\n\r\n\tvar cycles = path.findLoops(relations);\r\n\tif(cycles.length){\r\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\r\n\t}else{\r\n\r\n\t\tvar planner = gantt._autoSchedulingPlanner;\r\n\t\tgantt._autoSchedulingPreferredDates(id, relations);\r\n\r\n\t\tvar plan = planner.generatePlan(relations);\r\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\r\n\r\n\t\tif(updateCallback){\r\n\t\t\tupdateCallback(updatedTasks);\r\n\t\t}\r\n\t}\r\n\r\n\tgantt._autoscheduling_in_progress = false;\r\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\r\n\r\n\treturn updatedTasks;\r\n};\r\n\r\ngantt.autoSchedule = function(id, inclusive){\r\n\r\n\tif(inclusive === undefined){\r\n\t\tinclusive = true;\r\n\t}else{\r\n\t\tinclusive = !!inclusive;\r\n\t}\r\n\tvar relations =  gantt._autoSchedulingPath.getLinkedTasks(id, inclusive);\r\n\tgantt._autoSchedule(id, relations, gantt._finalizeAutoSchedulingChanges);\r\n};\r\n\r\ngantt._finalizeAutoSchedulingChanges = function(updatedTasks){\r\n\tfunction resetTime(task){\r\n\t\tif(batchUpdate)\r\n\t\t\treturn;\r\n\r\n\t\tvar start = task.start_date.valueOf(),\r\n\t\t\tend = task.end_date.valueOf();\r\n\r\n\t\tgantt.resetProjectDates(task);\r\n\t\tif(task.start_date.valueOf() != start || task.end_date.valueOf() != end){\r\n\t\t\tbatchUpdate = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar children = gantt.getChildren(task.id);\r\n\t\tfor(var i = 0; !batchUpdate && i < children.length; i++){\r\n\t\t\tresetTime(gantt.getTask(children[i]));\r\n\t\t}\r\n\t}\r\n\r\n\tvar batchUpdate = false;\r\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\r\n\tif(updatedTasks.length == 1){\r\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\r\n\t}else if(updatedTasks.length){\r\n\t\tbatchUpdate = true;\r\n\t}\r\n\r\n\tfunction payload(){\r\n\t\tfor(var i = 0; i < updatedTasks.length; i++){\r\n\t\t\tgantt.updateTask(updatedTasks[i]);\r\n\t\t}\r\n\t}\r\n\tif(batchUpdate){\r\n\t\tgantt.batchUpdate(payload);\r\n\t}else{\r\n\t\tpayload();\r\n\t}\r\n\r\n};\r\n\r\ngantt.isCircularLink = function(link){\r\n\treturn !!gantt._getConnectedGroup(link);\r\n\r\n};\r\n\r\ngantt._getConnectedGroup = function(link){\r\n\tvar manager = gantt._autoSchedulingPath;\r\n\r\n\tvar allRelations = manager.getLinkedTasks();\r\n\tif(!gantt.isLinkExists(link.id)){\r\n\t\tallRelations = allRelations.concat(gantt._formatLink(link));\r\n\t}\r\n\r\n\tvar cycles = manager.findLoops(allRelations);\r\n\r\n\tvar found = false;\r\n\tfor(var i = 0; (i < cycles.length) && !found; i++){\r\n\t\tvar links = cycles[i].links;\r\n\t\tfor(var j = 0; j < links.length; j++){\r\n\t\t\tif(links[j] == link.id){\r\n\t\t\t\treturn cycles[i];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn null;\r\n};\r\n\r\ngantt.findCycles = function(){\r\n\tvar manager = gantt._autoSchedulingPath;\r\n\r\n\tvar allRelations = manager.getLinkedTasks();\r\n\treturn manager.findLoops(allRelations);\r\n};\r\n\r\ngantt._attachAutoSchedulingHandlers = function(){\r\n\r\n\tgantt._autoScheduleAfterLinkChange = function (linkId, link) {\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tgantt.autoSchedule(link.source);\r\n\t\t}\r\n\t};\r\n\r\n\tgantt.attachEvent(\"onAfterLinkUpdate\", gantt._autoScheduleAfterLinkChange);\r\n\tgantt.attachEvent(\"onAfterLinkAdd\", gantt._autoScheduleAfterLinkChange);\r\n\r\n\tgantt.attachEvent(\"onAfterLinkDelete\", function(id, link){\r\n\t\tif (this.config.auto_scheduling && !this._autoscheduling_in_progress && this.isTaskExists(link.target)) {\r\n\t\t\t// after link deleted - auto schedule target for other relations that may be left\r\n\t\t\tvar target = this.getTask(link.target);\r\n\t\t\tvar predecessors = this._getPredecessors(target);\r\n\t\t\tif(predecessors.length){\r\n\t\t\t\tthis.autoSchedule(predecessors[0].source, false);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\tgantt.attachEvent(\"onParse\", function(){\r\n\t\tif (gantt.config.auto_scheduling && gantt.config.auto_scheduling_initial) {\r\n\t\t\tgantt.autoSchedule();\r\n\t\t}\r\n\t});\r\n\r\n\tgantt._preventCircularLink = function(id, link){\r\n\t\tif(gantt.isCircularLink(link)){\r\n\t\t\tgantt.callEvent(\"onCircularLinkError\", [link, gantt._getConnectedGroup(link)]);\r\n\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\r\n\tgantt._preventDescendantLink = function(id, link){\r\n\t\tvar source = gantt.getTask(link.source),\r\n\t\t\ttarget = gantt.getTask(link.target);\r\n\r\n\t\tif(!gantt.config.auto_scheduling_descendant_links){\r\n\t\t\tif((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventCircularLink);\r\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventDescendantLink);\r\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventCircularLink);\r\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventDescendantLink);\r\n\r\n\tgantt._datesNotEqual = function(dateA, dateB, taskA, taskB){\r\n\t\tif(dateA.valueOf() > dateB.valueOf()){\r\n\t\t\treturn this._hasDuration({start_date: dateB, end_date: dateA, task: taskB});\r\n\t\t}else{\r\n\t\t\treturn this._hasDuration({start_date: dateA, end_date: dateB, task: taskA});\r\n\t\t}\r\n\t};\r\n\tgantt._notEqualTaskDates = function(task1, task2){\r\n\t\tif (this._datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\r\n\t\t\t((this._datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\r\n\t\t\t\ttask1.duration != task2.duration) && task1.type != gantt.config.types.milestone)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n\r\n\tvar relations;\r\n\tvar movedTask;\r\n\tgantt.attachEvent(\"onBeforeTaskDrag\", function(id, mode, task){\r\n\t\tif(gantt.config.auto_scheduling_move_projects){\r\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\r\n\t\t\trelations = gantt._autoSchedulingPath.getLinkedTasks(id, true);\r\n\t\t\tmovedTask = id;\r\n\t\t}\r\n\t\treturn true;\r\n\t});\r\n\r\n\tfunction resetToStartLinksLags(taskId, relations){\r\n\t\tvar skipped = false;\r\n\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\tvar originalLink = gantt.getLink(relations[i].id);\r\n\t\t\tif(originalLink.type == gantt.config.links.start_to_start || originalLink.type == gantt.config.links.start_to_finish){\r\n\t\t\t\trelations.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t\tskipped = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(skipped){\r\n\t\t\tvar presentLinks = {};\r\n\t\t\tfor(var i = 0; i < relations.length; i++){\r\n\t\t\t\tpresentLinks[relations[i].id] = true;\r\n\t\t\t}\r\n\r\n\t\t\tvar updatedLinks = gantt._autoSchedulingPath.getLinkedTasks(taskId, true);\r\n\t\t\tfor(var i = 0; i < updatedLinks.length; i++){\r\n\t\t\t\tif(!presentLinks[updatedLinks[i].id]){\r\n\t\t\t\t\trelations.push(updatedLinks[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgantt._autoScheduleAfterDND = function(taskId, task){\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tvar newTask = this.getTask(taskId);\r\n\t\t\tif (gantt._notEqualTaskDates(task, newTask)){\r\n\t\t\t\tif(gantt.config.auto_scheduling_move_projects && movedTask == taskId){\r\n\r\n\t\t\t\t\tif(gantt.calculateDuration(task) != gantt.calculateDuration(newTask)){\r\n\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\r\n\t\t\t\t\t\t// recalculate these links if task duration has changed\r\n\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tgantt._autoSchedule(taskId, relations, gantt._finalizeAutoSchedulingChanges);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tgantt.autoSchedule(newTask.id);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\trelations = null;\r\n\t\tmovedTask = null;\r\n\t\treturn true;\r\n\t};\r\n\r\n\tgantt._lightBoxChangesHandler = function (taskId, task) {\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tvar oldTask = this.getTask(taskId);\r\n\t\t\tif (gantt._notEqualTaskDates(task, oldTask)) {\r\n\t\t\t\tgantt._autoschedule_lightbox_id = taskId;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\tgantt._lightBoxSaveHandler = function (taskId, task) {\r\n\r\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\r\n\t\t\tif (gantt._autoschedule_lightbox_id && gantt._autoschedule_lightbox_id == taskId) {\r\n\t\t\t\tgantt._autoschedule_lightbox_id = null;\r\n\t\t\t\tgantt.autoSchedule(task.id);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n\r\n\r\n\tgantt.attachEvent(\"onBeforeTaskChanged\", function(id, mode, task){ return gantt._autoScheduleAfterDND(id, task); });\r\n\tgantt.attachEvent(\"onLightboxSave\", gantt._lightBoxChangesHandler);\r\n\tgantt.attachEvent(\"onAfterTaskUpdate\", gantt._lightBoxSaveHandler);\r\n\r\n\r\n};\r\n\r\n\r\ngantt.attachEvent(\"onGanttReady\", function(){\r\n\tgantt._attachAutoSchedulingHandlers();\r\n\t// attach handlers only when initialized for the first time\r\n\tgantt._attachAutoSchedulingHandlers = function(){};\r\n});\r\n\r\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/ext/auto_scheduling.js\n// module id = 3\n// module chunks = 1","var units = {\r\n\t\"second\": 1,\r\n\t\"minute\": 60,\r\n\t\"hour\": 60 * 60,\r\n\t\"day\": 60 * 60 * 24,\r\n\t\"week\": 60 * 60 * 24 * 7,\r\n\t\"month\": 60 * 60 * 24 * 30,\r\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\r\n\t\"year\": 60 * 60 * 24 * 365\r\n};\r\nfunction getSecondsInUnit(unit){\r\n\treturn units[unit] || units.hour;\r\n}\r\n\r\nfunction forEach(arr, callback){\r\n\tvar workArray = arr.slice();\r\n\tfor(var i = 0; i < workArray.length; i++){\r\n\t\tcallback(workArray[i], i);\r\n\t}\r\n}\r\n\r\nfunction arrayMap(arr, callback){\r\n\tvar workArray = arr.slice();\r\n\tvar resArray = [];\r\n\r\n\tfor(var i = 0; i < workArray.length; i++){\r\n\t\tresArray.push(callback(workArray[i], i));\r\n\t}\r\n\r\n\treturn resArray;\r\n}\r\n\r\nmodule.exports = {\r\n\tgetSecondsInUnit: getSecondsInUnit,\r\n\tforEach: forEach,\r\n\tarrayMap: arrayMap\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./sources/utils/helpers.js\n// module id = 4\n// module chunks = 1"],"sourceRoot":""}